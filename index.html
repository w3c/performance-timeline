<!DOCTYPE html>
<html>
<head>
  <title>Performance Timeline</title>
  <meta charset='utf-8'>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' async class=
  'remove'></script>
  <script class='remove'>
    var respecConfig = {
      github: "https://github.com/w3c/performance-timeline/",
      shortName: "performance-timeline",
      level: 2,
      latestVersion: "TR/performance-timeline/",
      specStatus: "ED",
      editors: [
        {
          name: "Nicolás Peña Moreno",
          url: 'https://github.com/npm1',
          mailto: "npm@chromium.org",
          company: "Google",
          companyURL: "https://www.google.com/",
          w3cid: "103755",
        },
      ],
      formerEditors: [
        {
          name: "Ilya Grigorik",
          url: "https://www.igvita.com/",
          mailto: "igrigorik@gmail.com",
          company: "Google",
          companyURL: "https://www.google.com/",
          w3cid: "56102",
        },
        {
          name: "Jatinder Mann",
          mailto: "jmann@microsoft.com",
          company: "Microsoft Corp.",
          note: "Until November 2014",
        },
        {
          name: "Zhiheng Wang",
          company: "Google",
          note: "Until July 2013",
        },
      ],
      group:"webperf",
      testSuiteURI:
        "https://github.com/web-platform-tests/wpt/tree/master/performance-timeline",
      lint: {
        "check-punctuation": true,
      },
      doJsonLd: true,
      xref: ["hr-time-3", "infra", "html", "dom"],
      mdn: "performance-timeline",
    };
  </script>
</head>
<body>
  <section id='abstract'>
    <p>This specification extends the High Resolution Time specification
    [[HR-TIME-3]] by providing methods to store and retrieve high resolution
    performance metric data.</p>
  </section>
  <section id='sotd'>
    <p>Performance Timeline Level 2 replaces the first version of
    [[PERFORMANCE-TIMELINE]] and includes:</p>
    <ul>
      <li>Extends the base definition of the {{Performance}} interface defined by
      [[HR-TIME-3]];
      </li>
      <li>Exposes {{PerformanceEntry}} in Web Workers [[WORKERS]];
      </li>
      <li>Adds support for {{PerformanceObserver}}.
      </li>
    </ul>
  </section>
  <section class='informative'>
    <h2>Introduction</h2>
    <p>Accurately measuring performance characteristics of web applications is
    an important aspect of making web applications faster. This specification
    defines the necessary <a>Performance Timeline</a> primitives that enable
    web developers to access, instrument, and retrieve various performance
    metrics from the full lifecycle of a web application.</p>
    <p>[[NAVIGATION-TIMING-2]], [[RESOURCE-TIMING-2]], and [[USER-TIMING-2]]
    are examples of specifications that define timing information related to
    the navigation of the document, resources on the page, and developer
    scripts, respectively. Together these and other performance interfaces
    define performance metrics that describe the <a>Performance Timeline</a> of
    a web application. For example, the following script shows how a developer
    can access the <a>Performance Timeline</a> to obtain performance metrics
    related to the navigation of the document, resources on the page, and
    developer scripts:</p>
    <pre class="example html">
      &lt;!doctype html&gt;
      &lt;html&gt;
      &lt;head&gt;&lt;/head&gt;
      &lt;body onload="init()"&gt;
        &lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
        &lt;script&gt;
          function init() {
            // see [[USER-TIMING-2]]
            performance.mark("startWork");
            doWork(); // Some developer code
            performance.mark("endWork");
            measurePerf();
          }
          function measurePerf() {
            performance
              .getEntries()
              .map(entry =&gt; JSON.stringify(entry, null, 2))
              .forEach(json =&gt; console.log(json));
          }
        &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>Alternatively, the developer can observe the <a>Performance Timeline</a>
    and be notified of new performance metrics and, optionally, previously
    buffered performance metrics of specified type, via the
    <a>PerformanceObserver</a> interface.</p>
    <p>The <a>PerformanceObserver</a> interface was added in Performance
    Timeline Level 2 and is designed to address limitations of the buffer-based
    approach shown in the first example. By using the PerformanceObserver
    interface, the application can:</p>
    <ul>
      <li>Avoid polling the timeline to detect new metrics</li>
      <li>Eliminate costly deduplication logic to identify new metrics</li>
      <li>Eliminate race conditions with other consumers that may want to
      manipulate the buffer</li>
    </ul>
    <p>The developer is encouraged to use <a>PerformanceObserver</a> where
    possible. Further, new performance API's and metrics may only be available
    through the <a>PerformanceObserver</a> interface. The observer works by
    specifying a callback in the constructor and specifying the performance
    entries it's interested in via the <a data-link-for=
    "PerformanceObserver">observe()</a> method. The user agent chooses when to
    execute the callback, which receives performance entries that have been
    queued.</p>
    <p>There are special considerations regarding initial page load when using
    the <a>PerformanceObserver</a> interface: a registration must be active to
    receive events but the registration script may not be available or may not
    be desired in the critical path. To address this, user agents buffer some
    number of events while the page is being constructed, and these buffered
    events can be accessed via the <a data-link-for=
    "PerformanceObserverInit">buffered</a> flag when registering the observer.
    When this flag is set, the user agent retrieves and dispatches events that
    it has buffered, for the specified entry type, and delivers them in the
    first callback after the <a data-link-for=
    "PerformanceObserver">observe()</a> call occurs.</p>
    <p class="note">The number of buffered events is determined by the
    specification that defines the metric and buffering is intended to used for
    first-N events only; buffering is not unbounded or continuous.</p>
    <pre class="example">
    &lt;!doctype html&gt;
    &lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
    &lt;script&gt;
    // Know when the entry types we would like to use are not supported.
    function detectSupport(entryTypes) {
      for (const entryType of entryTypes) {
        if (!PerformanceObserver.supportedEntryTypes.includes(entryType)) {
          // Indicate to client-side analytics that |entryType| is not supported.
        }
      }
    }
    detectSupport(["resource", "mark", "measure"]);
    const userTimingObserver = new PerformanceObserver(list =&gt; {
      list
        .getEntries()
        // Get the values we are interested in
        .map(({ name, entryType, startTime, duration }) =&gt; {
          const obj = {
            "Duration": duration,
            "Entry Type": entryType,
            "Name": name,
            "Start Time": startTime,
          };
          return JSON.stringify(obj, null, 2);
        })
        // Display them to the console.
        .forEach(console.log);
      // Disconnect after processing the events.
      userTimingObserver.disconnect();
    });
    // Subscribe to new events for User-Timing.
    userTimingObserver.observe({entryTypes: ["mark", "measure"]});
    const resourceObserver = new PerformanceObserver(list =&gt; {
      list
        .getEntries()
        // Get the values we are interested in
        .map(({ name, startTime, fetchStart, responseStart, responseEnd }) =&gt; {
          const obj = {
            "Name": name,
            "Start Time": startTime,
            "Fetch Start": fetchStart,
            "Response Start": responseStart,
            "Response End": responseEnd,
          };
          return JSON.stringify(obj, null, 2);
        })
        // Display them to the console.
        .forEach(console.log);
      // Disconnect after processing the events.
      resourceObserver.disconnect();
    });
    // Retrieve buffered events and subscribe to newer events for Resource Timing.
    resourceObserver.observe({type: "resource", buffered: true});
    &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    </pre>
  </section>
  <section id="conformance">
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant).</p>
  </section>
  <section>
    <h2><dfn>Performance Timeline</dfn></h2>
    <p>Each <a>global object</a> has:</p>
    <ul>
      <li>a <dfn>performance observer task queued flag</dfn></li>
      <li>a <dfn>list of <a>registered performance observer</a> objects</dfn>
      that is initially empty</li>
      <li>a <dfn>performance entry buffer map</dfn> <a data-cite=
      "infra">map</a>, <a>keyed</a> on a <code>DOMString</code>, representing
      the entry type to which the buffer belongs. The <a data-cite=
      "infra">map</a>'s <a data-cite="INFRA#map-value">value</a> is the
      following tuple:
        <ul>
          <li>A <dfn>performance entry buffer</dfn> to store
          <a>PerformanceEntry</a> objects, that is initially empty.
          </li>
          <li>An integer <dfn>maxBufferSize</dfn>, initialized to the
            <a href="https://w3c.github.io/timing-entrytypes-registry/#registry">
            registry</a> value for this entry type.
          </li>
          <li>A <code>boolean</code> <dfn>availableFromTimeline</dfn>,
          initialized to the <a href=
          "https://w3c.github.io/timing-entrytypes-registry/#registry">registry</a>
          value for this entry type.
          </li>
          <li>An integer <dfn>dropped entries count</dfn> that is initially 0.</li>
        </ul>
      </li>
    </ul>
    <p>In order to get the <dfn>relevant performance entry tuple</dfn>, given
    <var>entryType</var> and <var>globalObject</var> as input, run the
    following steps:</p>
    <ol>
      <li>Let <var>map</var> be the <a>performance entry buffer map</a>
      associated with <var>globalObject</var>.
      </li>
      <li>Return the result of <a>getting the value of an entry</a> from <var>
        map</var>, given <var>entryType</var> as the <a>key</a>.
      </li>
    </ol>
    <section data-dfn-for="Performance" data-link-for="Performance">
      <h2>Extensions to the {{Performance}} interface</h2>
      <p>This extends the {{Performance}} interface from [[HR-TIME-3]] and
      hosts performance related attributes and methods used to retrieve the
      performance metric data from the <a>Performance Timeline</a>.</p>
      <pre class="idl">
      partial interface Performance {
        PerformanceEntryList getEntries ();
        PerformanceEntryList getEntriesByType (DOMString type);
        PerformanceEntryList getEntriesByName (DOMString name, optional DOMString type);
      };
      typedef sequence&lt;PerformanceEntry&gt; PerformanceEntryList;
      </pre>
      <p>The <dfn>PerformanceEntryList</dfn> represents a sequence of
      <a>PerformanceEntry</a>, providing developers with all the convenience
      methods found on JavaScript arrays.</p>
      <section>
        <h2><dfn>getEntries()</dfn> method</h2>
        <p>Returns a <a>PerformanceEntryList</a> object returned by the
        <a>filter buffer map by name and type</a> algorithm with
        <var>name</var> and <var>type</var> set to <code>null</code>.</p>
      </section>
      <section>
        <h2><dfn>getEntriesByType()</dfn> method</h2>
        <p>Returns a <a>PerformanceEntryList</a> object returned by <a>filter
        buffer map by name and type</a> algorithm with <var>name</var> set to
        <code>null</code>, and <var>type</var> set to the method's input
        <code>type</code> parameter.</p>
      </section>
      <section>
        <h2><dfn>getEntriesByName()</dfn> method</h2>
        <p>Returns a <a>PerformanceEntryList</a> object returned by <a>filter
        buffer map by name and type</a> algorithm with <var>name</var> set to
        the method input <code>name</code> parameter, and <var>type</var> set
        to <code>null</code> if optional `entryType` is omitted, or set to the
        method's input <code>type</code> parameter otherwise.</p>
      </section>
    </section>
  </section>
  <section data-dfn-for="PerformanceEntry" data-link-for="PerformanceEntry">
    <h2>The <dfn>PerformanceEntry</dfn> interface</h2>
    <p>The <a>PerformanceEntry</a> interface hosts the performance data of
    various metrics.</p>
    <pre class='idl'>
      [Exposed=(Window,Worker)]
      interface PerformanceEntry {
        readonly    attribute DOMString           name;
        readonly    attribute DOMString           entryType;
        readonly    attribute DOMHighResTimeStamp startTime;
        readonly    attribute DOMHighResTimeStamp duration;
        [Default] object toJSON();
      };</pre>
    <dl>
      <dt><dfn>name</dfn></dt>
      <dd>
        This attribute MUST return an identifier for this
        <a>PerformanceEntry</a> object. This identifier does not have to be
        unique.
      </dd>
      <dt><dfn>entryType</dfn></dt>
      <dd>
        This attribute MUST return the type of the interface represented by
        this <a>PerformanceEntry</a> object.
        <p class="note">All `entryType` values are defined in the
        relevant<a href=
        "https://w3c.github.io/timing-entrytypes-registry/#registry">registry</a>.
        Examples include: <code>"mark"</code> and <code>"measure"</code>
        [[USER-TIMING-2]], <code>"navigation"</code> [[NAVIGATION-TIMING-2]],
        <code>"resource"</code> [[RESOURCE-TIMING-2]],
        <!-- TODO: add long task spec reference -->
         and <code>"longtask"</code>.</p>
      </dd>
      <dt><dfn>startTime</dfn></dt>
      <dd>This attribute MUST return the time value of the first recorded
      timestamp of this performance metric. If the startTime concept doesn't
      apply, a performance metric may choose to return a `startTime` of
      <code>0</code>.</dd>
      <dt><dfn>duration</dfn></dt>
      <dd>
        This attribute MUST return the time value of the duration of the entire
        event being recorded by this <a>PerformanceEntry</a>. Typically, this
        would be the time difference between the last recorded timestamp and
        the first recorded timestamp of this <a>PerformanceEntry</a>. If the
        duration concept doesn't apply, a performance metric may choose to
        return a `duration` of <code>0</code>.
      </dd>
    </dl>
    <p>When <dfn>toJSON</dfn> is called, run [[WebIDL]]'s <a>default toJSON
    steps</a>.</p>
  </section>
  <section data-link-for="PerformanceObserver" data-dfn-for=
  "PerformanceObserver">
    <h2>The <dfn>PerformanceObserver</dfn> interface</h2>
    <p>The <a>PerformanceObserver</a> interface can be used to observe the
    <a>Performance Timeline</a> to be notified of new performance metrics as
    they are recorded, and optionally buffered performance metrics.</p>
    <p>Each <a>PerformanceObserver</a> has these associated concepts:</p>
    <ul>
      <li>A <dfn>PerformanceObserverCallback</dfn> <dfn>observer callback</dfn> set on creation.
      </li>
      <li>A <a>PerformanceEntryList</a> object called the <dfn>observer
      buffer</dfn> that is initially empty.
      </li>
      <li>A <code>DOMString</code> <dfn>observer type</dfn> which is initially
      <code>"undefined"</code>.</li>
      <li>A boolean <dfn>requires dropped entries</dfn> which is initially set to false.</li>
    </ul>
    <p>The `PerformanceObserver(callback)` constructor must create a new
    <a>PerformanceObserver</a> object with its <a>observer callback</a>
    set to <var>callback</var> and then return it.</p>
    <p>A <dfn>registered performance observer</dfn> is a <a>struct</a>
    consisting of an <dfn>observer</dfn> member (a <a>PerformanceObserver</a>
    object) and an <dfn>options list</dfn> member (a list of
    <a>PerformanceObserverInit</a> dictionaries).</p>
    <pre class="idl">
      callback PerformanceObserverCallback = undefined (PerformanceObserverEntryList entries,
                                                   PerformanceObserver observer,
                                                   optional PerformanceObserverCallbackOptions options = {});
      [Exposed=(Window,Worker)]
      interface PerformanceObserver {
        constructor(PerformanceObserverCallback callback);
        undefined observe (optional PerformanceObserverInit options = {});
        undefined disconnect ();
        PerformanceEntryList takeRecords();
        [SameObject] static readonly attribute FrozenArray&lt;DOMString&gt; supportedEntryTypes;
      };
    </pre>
    <p class="note">To keep the performance overhead to minimum the application
    ought to only subscribe to event types that it is interested in, and
    disconnect the observer once it no longer needs to observe the performance
    data. Filtering by name is not supported, as it would implicitly require a
    subscription for all event types — this is possible, but discouraged, as it
    will generate a significant volume of events.</p>
    <section data-dfn-for="PerformanceObserverCallbackOptions" data-link-for=
    "PerformanceObserverCallbackOptions">>
      <h2><dfn>PerformanceObserverCallbackOptions</dfn> dictionary</h2>
      <pre class="idl">
        dictionary PerformanceObserverCallbackOptions {
          unsigned long long droppedEntriesCount;
        };
      </pre>
      <dl>
        <dt><dfn>droppedEntriesCount</dfn></dt>
        <dd>An integer representing the dropped entries count for the entry types that the
        observer is observing when the <a>PerformanceObserver</a>'s <a>requires dropped entries</a>
        is set.</dd>
      </dl>
</section>
    <section>
      <h2><dfn>observe()</dfn> method</h2>
      <p>The <a>observe()</a> method instructs the user agent to <dfn>register
      the observer</dfn> and must run these steps:</p>
      <ol data-link-for="PerformanceObserverInit">
        <li>Let <var>relevantGlobal</var> be <a>this</a>'s <a>relevant
        global object</a>.
        </li>
        <li>If <var>options</var>'s <a>entryTypes</a> and <a>type</a> members
        are both omitted, then [=exception/throw=] a {{"TypeError"}}.
        </li>
        <li>If <var>options</var>'s <a>entryTypes</a> is present and any other
        member is also present, then [=exception/throw=] a {{"TypeError"}}.
        </li>
        <li>Update or check <a>this</a>'s <a>observer type</a> by running these
        steps:
          <ol>
            <li>If <a>this</a>'s <a>observer type</a> is
            <code>"undefined"</code>:
              <ol>
                <li>If <var>options</var>'s <a>entryTypes</a> member is
                present, then set <a>this</a>'s <a>observer type</a> to
                <code>"multiple"</code>.
                </li>
                <li>If <var>options</var>'s <a>type</a> member is present, then
                set <a>this</a>'s <a>observer type</a> to
                <code>"single"</code>.
                </li>
              </ol>
            </li>
            <li>If <a>this</a>'s <a>observer type</a> is
            <code>"single"</code> and <var>options</var>'s <a>entryTypes</a>
            member is present, then [=exception/throw=] an
            {{"InvalidModificationError"}}.
            </li>
            <li>If <a>this</a>'s <a>observer type</a> is
            <code>"multiple"</code> and <var>options</var>'s <a>type</a> member
            is present, then [=exception/throw=] an
            {{"InvalidModificationError"}}.
            </li>
          </ol>
        </li>
        <li>Set <a>this</a>'s <a>requires dropped entries</a> to true.</li>
        <li>If <a>this</a>'s <a>observer type</a> is
        <code>"multiple"</code>, run the following steps:
          <ol>
            <li>Let <var>entry types</var> be <var>options</var>'s
            <a>entryTypes</a> sequence.
            </li>
            <li>Remove all types from <var>entry types</var> that are not
            contained in <var>relevantGlobal</var>'s <a>frozen array of
            supported entry types</a>. The user agent SHOULD notify developers
            if <var>entry types</var> is modified. For example, a console
            warning listing removed types might be appropriate.
            </li>
            <li>If the resulting <var>entry types</var> sequence is an empty
            sequence, abort these steps. The user agent SHOULD notify
            developers when the steps are aborted to notify that registration
            has been aborted. For example, a console warning might be
            appropriate.</li>
            <li>If the <a>list of registered performance observer objects</a>
            of <var>relevantGlobal</var> contains a <a>registered performance
            observer</a> whose <a>observer</a> is <a>this</a>,
            replace its <a>options list</a> with a list containing
            <var>options</var> as its only item.
            </li>
            <li>Otherwise, create and append a <a>registered performance
            observer</a> object to the <a>list of registered performance
            observer objects</a> of <var>relevantGlobal</var>, with
            <a>observer</a> set to <a>this</a> and <a>options list</a> set to a
            list containing <var>options</var> as its only item.
            </li>
          </ol>
        </li>
        <li>Otherwise, run the following steps:
          <ol>
            <li>Assert that <a>this</a>'s <a>observer type</a> is
            <code>"single"</code>.
            </li>
            <li>If <var>options</var>'s <a>type</a> is not contained in the
            <var>relevantGlobal</var>'s <a>frozen array of supported entry
            types</a>, abort these steps. The user agent SHOULD notify
            developers when this happens, for instance via a console warning.
            </li>
            <li>If the <a>list of registered performance observer objects</a>
            of <var>relevantGlobal</var> contains a <a>registered performance
            observer</a> <var>obs</var> whose <a>observer</a> is <a>this</a>:
              <ol>
                <li>If <var>obs</var>'s <a>options list</a> contains a
                <a>PerformanceObserverInit</a> item <var>currentOptions</var>
                whose <a>type</a> is equal to <var>options</var>'s <a>type</a>,
                replace <var>currentOptions</var> with <var>options</var> in
                <var>obs</var>'s <a>options list</a>.
                </li>
                <li>Otherwise, append <var>options</var> to <var>obs</var>'s
                <a>options list</a>.
                </li>
              </ol>
            </li>
            <li>Otherwise, create and append a <a>registered performance
            observer</a> object to the <a>list of registered performance
            observer objects</a> of <var>relevantGlobal</var>, with
            <a>observer</a> set to the <a>this</a> and <a>options list</a> set
            to a list containing <var>options</var> as its only item.
            </li>
            <li>If <var>options</var>'s <a>buffered</a> flag is set:
              <ol>
                <li>Let <var>tuple</var> be the <a>relevant performance entry
                tuple</a> of <var>options</var>'s <a>type</a> and
                <var>relevantGlobal</var>.
                </li>
                <li><p>For each <var>entry</var> in <var>tuple</var>'s
                <a>performance entry buffer</a>:</p>
                  <ol>
                  <li>If <a href=
                    "https://w3c.github.io/timing-entrytypes-registry/#dfn-should-add-entry">
                    should add entry</a> with <var>entry</var> and <var>options</var> as
                    parameters returns true, [=list/append=] <var>entry</var> to the
                    <a>observer buffer</a>.</li>
                  </ol>
                </li>
                <li><a>Queue the PerformanceObserver task</a> with
                <var>relevantGlobal</var> as input.</li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
      <p class="note">A <a>PerformanceObserver</a> object needs to always call
      <a>observe()</a> with <var>options</var>'s <a data-link-for=
      "PerformanceObserverInit">entryTypes</a> set OR always call
      <a>observe()</a> with <var>options</var>'s <a data-link-for=
      "PerformanceObserverInit">type</a> set. If one <a>PerformanceObserver</a>
      calls <a>observe()</a> with <a data-link-for=
      "PerformanceObserverInit">entryTypes</a> and also calls observe with
      <a data-link-for="PerformanceObserverInit">type</a>, then an exception is
      thrown. This is meant to avoid confusion with how calls would stack. When
      using <a data-link-for="PerformanceObserverInit">entryTypes</a>, no other
      parameters in <a>PerformanceObserverInit</a> can be used. In addition,
      multiple <a>observe()</a> calls will override for backwards compatibility
      and because a single call should suffice in this case. On the other hand,
      when using <a data-link-for="PerformanceObserverInit">type</a>, calls
      will stack because a single call can only specify one type. Calling
      <a>observe()</a> with a repeated <a data-link-for=
      "PerformanceObserverInit">type</a> will also override.</p>
      <section data-dfn-for="PerformanceObserverInit" data-link-for=
      "PerformanceObserverInit">
        <h2><dfn>PerformanceObserverInit</dfn> dictionary</h2>
        <pre class="idl">
          dictionary PerformanceObserverInit {
            sequence&lt;DOMString&gt; entryTypes;
            DOMString type;
            boolean buffered;
          };
          </pre>
        <dl>
          <dt><dfn>entryTypes</dfn></dt>
          <dd>A list of entry types to be observed. If present, the list MUST
          NOT be empty and all other members MUST NOT be present. Types not
          recognized by the user agent MUST be ignored.</dd>
        </dl>
        <dl>
          <dt><dfn>type</dfn></dt>
          <dd>A single entry type to be observed. A type that is not recognized
          by the user agent MUST be ignored. Other members may be present.</dd>
        </dl>
        <dl>
          <dt><dfn>buffered</dfn></dt>
          <dd>A flag to indicate whether buffered entries should be queued into
          observer's buffer.</dd>
        </dl>
      </section>
      <section data-dfn-for="PerformanceObserverEntryList" data-link-for=
      "PerformanceObserverEntryList">
        <h2><dfn>PerformanceObserverEntryList</dfn> interface</h2>
        <pre class="idl">
          [Exposed=(Window,Worker)]
          interface PerformanceObserverEntryList {
            PerformanceEntryList getEntries();
            PerformanceEntryList getEntriesByType (DOMString type);
            PerformanceEntryList getEntriesByName (DOMString name, optional DOMString type);
          };
          </pre>
          <p>Each {{PerformanceObserverEntryList}} object has an associated
          <dfn>entry list</dfn>, which consists of a {{PerformanceEntryList}} and is
          initialized upon construction.</p>
        <section>
          <h2><dfn>getEntries()</dfn> method</h2>
          <p>Returns a <a>PerformanceEntryList</a> object returned by <a>filter
          buffer by name and type</a> algorithm with <a>this</a>'s <a>entry list</a>,
          <var>name</var> and <var>type</var> set to <code>null</code>.</p>
        </section>
        <section>
          <h2><dfn>getEntriesByType()</dfn> method</h2>
          <p>Returns a <a>PerformanceEntryList</a> object returned by <a>filter
          buffer by name and type</a> algorithm with <a>this</a>'s <a>entry list</a>,
          <var>name</var> set to <code>null</code>, and <var>type</var> set to the
          method's input <code>type</code> parameter.</p>
        </section>
        <section>
          <h2><dfn>getEntriesByName()</dfn> method</h2>
          <p>Returns a <a>PerformanceEntryList</a> object returned by <a>filter
          buffer by name and type</a> algorithm with <a>this</a>'s <a>entry list</a>,
          <var>name</var> set to the method input <code>name</code> parameter, and
          <var>type</var> set to <code>null</code> if optional `entryType` is omitted,
          or set to the method's input <code>type</code> parameter otherwise.</p>
        </section>
      </section>
    </section>
    <section>
      <h2><dfn>takeRecords()</dfn> method</h2>
      <p>The <a>takeRecords()</a> method must return a copy of <a>this</a>'s
      <a>observer buffer</a>, and also empty <a>this</a>'s <a>observer
      buffer</a>.</p>
    </section>
    <section>
      <h2><dfn>disconnect()</dfn> method</h2>
      <p>The <a>disconnect()</a> method must do the following:</p>
      <ol>
        <li>Remove <a>this</a> from the <a>list of registered
        performance observer objects</a> of <a>relevant global object</a>.</li>
        <li>Empty <a>this</a>'s <a>observer buffer</a>.</li>
        <li>Empty <a>this</a>'s <a>options list</a>.</li>
      </ol>
    </section>
    <section>
      <h2><a>supportedEntryTypes</a> attribute</h2>
      <p>Each <a data-cite="HTML/webappapis.html#global-object">global
      object</a> has an associated <dfn>frozen array of supported entry
      types</dfn>, which is initialized to the <a data-cite=
      "WEBIDL/#es-frozen-array">FrozenArray</a> <a data-cite=
      "WEBIDL/#dfn-create-frozen-array">created</a> from the sequence of
      strings among the <a href=
      "https://w3c.github.io/timing-entrytypes-registry/#registry">registry</a>
      that are supported for the global object, in alphabetical order.</p>
      <p>When <dfn>supportedEntryTypes</dfn>'s attribute getter is called, run
      the following steps:</p>
      <ol>
        <li>Let <var>globalObject</var> be the <a data-cite=
        "HTML/webappapis.html#concept-settings-object-global">environment
        settings object's global object</a>.
        </li>
        <li>Return <var>globalObject</var>'s <a>frozen array of supported entry
        types</a>.
        </li>
      </ol>
      <p class="note">This attribute allows web developers to easily know which
      entry types are supported by the user agent.</p>
    </section>
  </section>
  <section>
    <h2>Processing</h2>
    <section data-link-for="PerformanceObserver">
      <h2>Queue a <code>PerformanceEntry</code></h2>
      <p>To <dfn>queue a PerformanceEntry</dfn> (<var>newEntry</var>), run
      these steps:</p>
      <ol>
        <li>Let <var>interested observers</var> be an initially empty set of
        <a>PerformanceObserver</a> objects.
        </li>
        <li>Let <var>entryType</var> be <var>newEntry</var>’s <a data-lt=
        "PerformanceEntry.entryType">entryType</a> value.
        </li>
        <li>Let <var>relevantGlobal</var> be <var>newEntry</var>'s <a>relevant
        global object</a>.
        </li>
        <li>For each <a>registered performance observer</a> <var>regObs</var> in
        <var>relevantGlobal</var>'s <a>list of registered performance observer objects</a>:
          <ol>
            <li><p>If <var>regObs</var>'s <a>options list</a> contains a
            <a>PerformanceObserverInit</a> <var>options</var> whose <a data-link-for=
            "PerformanceObserverInit">entryTypes</a> member includes
            <var>entryType</var> or whose <a data-link-for=
            "PerformanceObserverInit">type</a> member equals to
            <var>entryType</var>:</p>
            <ol>
              <li>If <a href=
                "https://w3c.github.io/timing-entrytypes-registry/#dfn-should-add-entry">
                should add entry</a> with <var>newEntry</var> and <var>options</var>
                returns true, append <var>regObs</var>'s <a>observer</a> to
                <var>interested observers</var>.
              </li>
            </ol>
            </li>
          </ol>
        </li>
        <li>For each <var>observer</var> in <var>interested observers</var>:
          <ol>
            <li>Append <var>newEntry</var> to <var>observer</var>'s <a>observer
            buffer</a>.
            </li>
          </ol>
        </li>
        <li>Let <var>tuple</var> be the <a>relevant performance entry tuple</a>
        of <var>entryType</var> and <var>relevantGlobal</var>.
        </li>
        <li>Let <var>isBufferFull</var> be the return value of the <a>determine if a performance
        entry buffer is full</a> algorithm with <var>tuple</var> as input.
        </li>
        <li>Let <var>shouldAdd</var> be the result of <a href=
        "https://w3c.github.io/timing-entrytypes-registry/#dfn-should-add-entry">should add
        entry</a> with <var>newEntry</var> as input.
        </li>
        <li>If <var>isBufferFull</var> is false and <var>shouldAdd</var> is true, [=list/append=]
        <var>newEntry</var> to <var>tuple</var>'s <a>performance entry buffer</a>.
        </li>
        <li><a>Queue the PerformanceObserver task</a> with
        <var>relevantGlobal</var> as input.
        </li>
      </ol>
    </section>
    <section data-link-for="PerformanceObserver">
      <h2>Queue the PerformanceObserver task</h2>
      <p>When asked to <dfn>queue the PerformanceObserver task</dfn>, given
      <var>relevantGlobal</var> as input, run the following steps:</p>
      <ol>
        <li>If <var>relevantGlobal</var>'s <a>performance observer task queued
        flag</a> is set, terminate these steps.
        </li>
        <li>Set <var>relevantGlobal</var>'s <a>performance observer task queued
        flag</a>.
        </li>
        <li>
          <a>Queue a task</a> that consists of running the following substeps.
          The <a>task source</a> for the queued task is the <dfn data-export="">performance
          timeline task source</dfn>.
          <ol>
            <li>Unset <a>performance observer task queued flag</a> of
            <var>relevantGlobal</var>.
            </li>
            <li>Let <var>notifyList</var> be a copy of
            <var>relevantGlobal</var>'s <a>list of registered performance
            observer objects</a>.
            </li>
            <li>For each <a>registered performance observer</a> object <var>registeredObserver</var>
            in <var>notifyList</var>, run these steps:
              <ol>
                <li>Let <var>po</var> be <var>registeredObserver</var>'s <a>observer</a>.</li>
                <li>Let <var>entries</var> be a copy of <var>po</var>’s
                <a>observer buffer</a>.
                </li>
                <li>If <var>entries</var> is empty, return.</li>
                <li>Empty <var>po</var>’s <a>observer buffer</a>.
                </li>
                <li>Let <var>observerEntryList</var> be a new
                {{PerformanceObserverEntryList}}, with its <a>entry list</a> set
                to <var>entries</var>.
                </li>
                <li>Let <var>droppedEntriesCount</var> be null.</li>
                <li>If <var>po</var>'s <a>requires dropped entries</a> is set, perform the following
                steps:
                  <ol>
                    <li>Set <var>droppedEntriesCount</var> to 0.</li>
                    <li>For each <a>PerformanceObserverInit</a> <var>item</var> in
                    <var>registeredObserver</var>'s <a>options list</a>:
                    <ol>
                      <li>For each <a data-cite="WEBIDL#idl-DOMString">DOMString</a>
                      <var>entryType</var> that appears either as <var>item</var>'s <a data-link-for=
                      "PerformanceObserverInit">type</a> or in <var>item</var>'s
                      <a data-link-for="PerformanceObserverInit">entryTypes</a>:
                        <ol>
                          <li>Let <var>map</var> be <var>relevantGlobal</var>'s <a>performance entry
                          buffer map</a>.</li>
                          <li>Let <var>tuple</var> be the result of <a>getting the value of entry</a>
                          on <var>map</var> given <var>entryType</var> as <a>key</a>.</li>
                          <li>Increase <var>droppedEntriesCount</var> by <var>tuple</var>'s
                          <a>dropped entries count</a>.</li>
                        </ol>
                      </li>
                    </ol>
                    </li>
                    <li>Set <var>po</var>'s <a>requires dropped entries</a> to false.</li>
                  </ol>
                </li>
                <li>Let <var>callbackOptions</var> be a <a>PerformanceObserverCallbackOptions</a>
                with its <a data-link-for="PerformanceObserverCallbackOptions">droppedEntriesCount</a>
                set to <var>droppedEntriesCount</var> if <var>droppedEntriesCount</var> is not null,
                otherwise unset.</li>
                <li>Call <var>po</var>’s <a>observer callback</a> with
                <var>observerEntryList</var> as the first argument, with <var>po</var>
                as the second argument and as <a>callback this value</a>, and with
                <var>callbackOptions</var> as the third argument. If this [=exception/throws=]
                an exception, <a>report the exception</a>.
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
      <p>The <i>performance timeline</i> <a data-lt="queue a task">task
      queue</a> is a low priority queue that, if possible, should be processed
      by the user agent during idle periods to minimize impact of performance
      monitoring code.</p>
    </section>
    <section data-link-for="PerformanceEntry">
      <h2>Filter buffer map by name and type</h2>
      <p>When asked to run the <dfn>filter buffer map by name and type</dfn>
      algorithm with optional <var>name</var> and <var>type</var>, run the
      following steps:</p>
      <ol>
        <li>Let <var>result</var> be an initially empty <a>list</a>.
        </li>
        <li>Let <var>map</var> be the <a>performance entry buffer map</a>
        associated with the <a>relevant global object</a> of <a>this</a>.
        </li>
        <li>Let <var>tuple list</var> be an empty <a>list</a>.
        </li>
        <li>If <var>type</var> is not null, append the result of <a>getting the
        value of entry</a> on <var>map</var> given <var>type</var> as
        <a>key</a> to <var>tuple list</var>. Otherwise, assign the result of
        <a data-cite="INFRA/#map-getting-the-values">get the values</a> on
        <var>map</var> to <var>tuple list</var>.
        </li>
        <li>For each <var>tuple</var> in <var>tuple list</var>, run the
        following steps:
          <ol>
            <li>Let <var>buffer</var> be <var>tuple</var>'s <a>performance
            entry buffer</a>.
            </li>
            <li>If <var>tuple</var>'s <a>availableFromTimeline</a> is false,
            continue to the next <var>tuple</var>.
            </li>
            <li>Let <var>entries</var> be the result of running <a>filter
            buffer by name and type</a> with <var>buffer</var>, <var>name</var>
            and <var>type</var> as inputs.
            </li>
            <li>For each <var>entry</var> in <var>entries</var>,
            [=list/append=] <var>entry</var> to <var>result</var>.</li>
          </ol>
        </li>
        <li>Sort <var>results</var>'s entries in chronological order with
        respect to <a>startTime</a>
        </li>
        <li>Return <var>result</var>.</li>
      </ol>
    </section>
    <section data-link-for="PerformanceEntry">
      <h2>Filter buffer by name and type</h2>
      <p>When asked to run the <dfn>filter buffer by name and type</dfn>
      algorithm, with <var>buffer</var>, <var>name</var>, and <var>type</var>
      as inputs, run the following steps:</p>
      <ol>
        <li>Let <var>result</var> be an initially empty <a>list</a>.
        </li>
        <li>For each <a>PerformanceEntry</a> <var>entry</var> in
        <var>buffer</var>, run the following steps:
          <ol>
            <li>If <var>type</var> is not null and if <var>type</var> is not
            <a data-cite=INFRA#string-is>identical to</a> <var>entry</var>'s
            <code>entryType</code> attribute, continue to next <var>entry</var>.
            </li>
            <li>If <var>name</var> is not null and if <var>name</var> is not
            <a data-cite=INFRA#string-is>identical to</a> <var>entry</var>'s
            <code>name</code> attribute, continue to next <var>entry</var>.
            </li>
            <li>[=list/append=] <var>entry</var> to <var>result</var>.</li>
          </ol>
        </li>
        <li>Sort <var>results</var>'s entries in chronological order with
        respect to <a>startTime</a>
        </li>
        <li>Return <var>result</var>.</li>
      </ol>
    </section>
    <section data-link-for="PerformanceObserver">
      <h2>Determine if a performance entry buffer is full</h2>
      <p>To <dfn>determine if a performance entry buffer is full</dfn>,
      with <var>tuple</var> as input, run the following
      steps:</p>
      <ol>
        <li>Let <var>num current entries</var> be the size of
        <var>tuple</var>'s <a>performance entry buffer</a>.
        </li>
        <li>If <var>num current entries</var> is less than <var>tuples</var>'s
        <a>maxBufferSize</a>, return false.
        </li>
        <li>Increase <var>tuple</var>'s <a>dropped entries count</a> by 1.</li>
        <li>Return true.</li>
      </ol>
    </section>
  </section>
  <section id="privacy-security">
    <h3>Privacy and Security</h3>
    <p>This specification extends the {{Performance}} interface defined by
    [[HR-TIME-3]] and provides methods to queue and retrieve entries from the
    <a>performance timeline</a>. Please refer to [[HR-TIME-3]] for privacy and
    security considerations of exposing high-resoluting timing information.</p>
  </section>
  <section>
    <h2>Dependencies</h2>
    <p>The [[INFRA]] specification defines the following: <dfn data-lt="keyed"
    data-cite="INFRA#map-key">key</dfn>, <dfn data-lt=
    "getting the value of entry" data-cite="INFRA#map-get">getting the value of
    an entry</dfn>.</p>
  </section>
  <section class="appendix" id="idl-index"></section>
  <section class="appendix">
    <h2>Acknowledgments</h2>
    <p>Thanks to Arvind Jain, Boris Zbarsky, Jatinder Mann, Nat Duca, Philippe
    Le Hegaret, Ryosuke Niwa, Shubhie Panicker, Todd Reifsteck, Yoav Weiss, and
    Zhiheng Wang, for their contributions to this work.</p>
  </section>
</body>
</html>
