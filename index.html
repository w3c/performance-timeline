<!DOCTYPE html>
<html>
<head>
  <title>Performance Timeline Level 2</title>
  <meta charset='utf-8'>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class=
  'remove'></script>
  <script class='remove'>
  var respecConfig = {
    shortName: "performance-timeline-2",
    useExperimentalStyles: true,
    specStatus: "ED",
    edDraftURI: "https://w3c.github.io/performance-timeline/",
    // publishDate: "2013-10-23",
    editors: [{
      name: "Ilya Grigorik",
      url: "https://www.igvita.com/",
      mailto: "igrigorik@gmail.com",
      company: "Google",
      companyURL: "https://www.google.com/",
      w3cid: "56102"
    },{
      name: "Jatinder Mann",
      mailto: "jmann@microsoft.com",
      company: "Microsoft Corp.",
      note: "Until November 2014"
    },{
      name: "Zhiheng Wang",
      company: "Google",
      note: "Until July 2013"
    }],
    wg: "Web Performance Working Group",
    wgURI: "https://www.w3.org/webperf/",
    license: "w3c-software-doc",
    wgPublicList: "public-web-perf",
    subjectPrefix: "[Performance Timeline]",
    format: "markdown",
    otherLinks: [{
      key: 'Repository',
      data: [{
        value: 'We are on GitHub',
        href: 'https://github.com/w3c/performance-timeline/'
      }, {
        value: 'Commit history',
        href: 'https://github.com/w3c/performance-timeline/commits/gh-pages/index.html'
      }, {
        value: 'File a bug',
        href: 'https://github.com/w3c/performance-timeline/issues?q=milestone:%22Level%202%22'
      }]
    },{
      key: 'Mailing list',
      data: [{
        value: 'public-web-perf@w3.org',
        href: 'https://lists.w3.org/Archives/Public/public-web-perf/'
      }]
    },{
      key: 'Implementation',
      data: [{
        value: 'Test Suite',
        href: 'http://w3c-test.org/performance-timeline/'
      }, {
        value: 'Test Suite repository',
        href: 'https://github.com/w3c/web-platform-tests/tree/master/performance-timeline'
      }]
    }],
    wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/45211/status"
  };
  </script>
</head>
<body>
  <section id='abstract'>
    <p>This specification extends the High Resolution Time specification
    [[!HR-TIME-2]] by providing methods to store and retrieve high resolution
    performance metric data.</p>
  </section>
  <section id='sotd'>
    <p>Performance Timeline Level 2 replaces the first version of
    [[PERFORMANCE-TIMELINE]] and includes:</p>
    <ul>
      <li>Extends the base definition of the <a>Performance</a> interface
      defined by [[HR-TIME-2]];
      </li>
      <li>Exposes <a>PerformanceEntry</a> in Web Workers [[WORKERS]];
      </li>
      <li>Adds support for <a data-lt='PerformanceObserver'>performance
      observers</a>.
      </li>
    </ul>
  </section>
  <section class='informative'>
    <h2>Introduction</h2>
    <p>Accurately measuring performance characteristics of web applications is
    an important aspect of making web applications faster. This specification
    defines the necessary <a>Performance Timeline</a> primitives that enable
    web developers to access, instrument, and retrieve various performance
    metrics from the full lifecycle of a web application.</p>
    <p>[[NAVIGATION-TIMING-2]], [[RESOURCE-TIMING-2]], and [[USER-TIMING-2]]
    are examples of specifications that define timing information related to
    the navigation of the document, resources on the page, and developer
    scripts, respectively. Together these and other performance interfaces
    define performance metrics that describe the <a>Performance Timeline</a> of
    a web application. For example, the following script shows how a developer
    can access the <a>Performance Timeline</a> to obtain performance metrics
    related to the navigation of the document, resources on the page, and
    developer scripts:</p>
    <pre class="example html">
      &lt;!doctype html&gt;
      &lt;html&gt;
      &lt;head&gt;&lt;/head&gt;
      &lt;body onload="init()"&gt;
        &lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
        &lt;script&gt;
          function init() {
            // see [[USER-TIMING-2]]
            performance.mark("startWork");
            doWork(); // Some developer code
            performance.mark("endWork");
            measurePerf();
          }
          function measurePerf() {
            performance
              .getEntries()
              .map(entry =&gt; JSON.stringify(entry, null, 2))
              .forEach(json =&gt; console.log(json));
          }
        &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
    <p>Alternatively, the developer can observe the <a>Performance Timeline</a>
    and be notified of new performance metrics and, optionally, previously
    buffered performance metrics of specified type, via the
    <a>PerformanceObserver</a> interface:</p>
    <pre class="example">
    &lt;!doctype html&gt;
    &lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
    &lt;script&gt;
    const observer = new PerformanceObserver(list =&gt; {
      list
        .getEntries()
        // Get the values we are interested in
        .map(({ name, entryType, startTime, duration }) =&gt; {
          const obj = {
            "Duration": duration,
            "Entry Type": entryType,
            "Name": name,
            "Start Time": startTime,
          };
          return JSON.stringify(obj, null, 2);
        })
        // Display them to the console
        .forEach(console.log);
      // maybe disconnect after processing the events.
      observer.disconnect();
    });
    // retrieve buffered events and subscribe to new events
    // for Resource-Timing and User-Timing
    observer.observe({
      entryTypes: ["resource", "mark", "measure"],
      buffered: true
    });
    &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    </pre>
    <p>The <a>PerformanceObserver</a> interface was added in Performance
    Timeline Level 2 and is designed to address limitations of the buffer-based
    approach shown in the first example. By using the PerformanceObserver
    interface, the application can:</p>
    <ul>
      <li>Avoid polling the timeline to detect new metrics</li>
      <li>Eliminate costly deduplication logic to identify new metrics</li>
      <li>Eliminate race conditions with other consumers that may want to
      manipulate the buffer</li>
    </ul>
    <p>The developer is encouraged to use <a>PerformanceObserver</a> where
    possible. Further, new performance API's and metrics may only be available
    through the <a>PerformanceObserver</a> interface.</p>
  </section>
  <section id="conformance">
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>The IDL fragments in this specification must be interpreted as required
    for [conforming IDL fragments], as described in the Web IDL specification.
    [[!WebIDL]]</p>
  </section>
  <section>
    <h2><dfn>Performance Timeline</dfn></h2>
    <p>Each <a>ECMAScript global environment</a> has:</p>
    <ul>
      <li>a <dfn>performance observer task queued flag</dfn> and an associated
      list of <a>registered performance observer</a> objects which is initially
      empty.
      </li>
      <li>a <dfn>performance entry buffer</dfn> to store
      <a>PerformanceEntry</a> objects. It is initially empty.
      </li>
      <li>a list of <a>registered performance timeline emitter</a> objects. It is initially empty.</li>
    </ul>

    <section>
      <h2>Register <var>emitter</var> with <a>Performance Timeline</a></h2>
      <p>An <var>emitter</var> represents a mechanism that can generate <a>PerformanceEntry</a> objects that are exposed to developers via the <a>Performance Timeline</a>. A <dfn>registered performance timeline emitter</dfn> consists of a:</p>
      <ul>
        <li><var>name</var> that MUST be unique.</li>
        <li><var>performance entry buffer</var> that stores <a>PerformanceEntry</a> objects generated by the emitter, which is initially empty and has a <var>max-size</var> that, if unspecified, is set to 150.</li>
      </ul>
    </section>

    <section data-dfn-for="Performance" data-link-for="Performance">
      <h2>Extensions to the <a>Performance</a> interface</h2>
      <p>This extends the <a>Performance</a> interface [[!HR-TIME-2]] and hosts
      performance related attributes and methods used to retrieve the
      performance metric data from the <a>Performance Timeline</a>.</p>
      <pre class="idl">
      partial interface Performance {
        PerformanceEntryList getEntries ();
        PerformanceEntryList getEntriesByType (DOMString type);
        PerformanceEntryList getEntriesByName (DOMString name, optional DOMString type);
      };
      typedef sequence&lt;PerformanceEntry&gt; PerformanceEntryList;
      </pre>
      <p>The <dfn>PerformanceEntryList</dfn> represents a sequence of
      <a>PerformanceEntry</a>, providing developers with all the convenience
      methods found on JavaScript arrays.</p>
      <section>
        <h2><dfn>getEntries()</dfn> method</h2>
        <p>Returns a <a>PerformanceEntryList</a> object returned by
        <a href="#filter-buffer-by-name-and-type"></a> algorithm with
        <var>buffer</var> set to <a>performance entry buffer</a>, and
        <var>name</var> and <var>type</var> set to `null`.</p>
      </section>
      <section>
        <h2><dfn>getEntriesByType()</dfn> method</h2>
        <p>Returns a <a>PerformanceEntryList</a> object returned by
        <a href="#filter-buffer-by-name-and-type"></a> algorithm with
        <var>buffer</var> set to <a>performance entry buffer</a>,
        <var>name</var> set to `null`, and <var>type</var> set
        to `type`.</p>
      </section>
      <section>
        <h2><dfn>getEntriesByName()</dfn> method</h2>
        <p>Returns a <a>PerformanceEntryList</a> object returned by
        <a href="#filter-buffer-by-name-and-type"></a> algorithm with
        <var>buffer</var> set to <a>performance entry buffer</a>,
        <var>name</var> set to `name`, and <var>type</var> set
        to `null` if optional `entryType` is omitted, and <var>type</var> set
        to `type` otherwise.</p>
      </section>
    </section>
    <section data-dfn-for="PerformanceEntry" data-link-for="PerformanceEntry">
      <h2>The <dfn>PerformanceEntry</dfn> interface</h2>
      <p>The <a>PerformanceEntry</a> interface hosts the performance data of
      various metrics.</p>
      <pre class='idl'>
      [Exposed=(Window,Worker)]
      interface PerformanceEntry {
        readonly    attribute DOMString           name;
        readonly    attribute DOMString           entryType;
        readonly    attribute DOMHighResTimeStamp startTime;
        readonly    attribute DOMHighResTimeStamp duration;
        [Default] object toJSON();
      };</pre>
      <dl>
        <dt><dfn>name</dfn></dt>
        <dd>This attribute MUST return an identifier for this
        <a>PerformanceEntry</a> object. This identifier does not have to be
        unique.</dd>
        <dt><dfn>entryType</dfn></dt>
        <dd>This attribute MUST return the type of the
        interface represented by this <a>PerformanceEntry</a> object.
        <p class="note">Example `entryType` values defined by other
        specifications include: <code>"mark"</code> and <code>"measure"</code>
        [[USER-TIMING-2]], <code>"navigation"</code> [[NAVIGATION-TIMING-2]],
        <code>"resource"</code> [[RESOURCE-TIMING-2]],
        <!-- TODO: add long task spec reference -->
         and <code>"longtask"</code>.</p></dd>
        <dt><dfn>startTime</dfn></dt>
        <dd>This attribute MUST return the time value of the
        first recorded timestamp of this performance metric. If the startTime
        concept doesn't apply, a performance metric may choose to return a
        `startTime` of <code>0</code>.</dd>
        <dt><dfn>duration</dfn></dt>
        <dd>This attribute MUST return the time value of the
      duration of the entire event being recorded by this
      <a>PerformanceEntry</a>. Typically, this would be the time difference
      between the last recorded timestamp and the first recorded timestamp of
      this <a>PerformanceEntry</a>. If the duration concept doesn't apply, a
      performance metric may choose to return a `duration` of
      <code>0</code>.</dd>
      </dl>
      <p>When <dfn>toJSON</dfn> is called, run [[!WebIDL]]'s
      <a data-cite="WEBIDL#default-tojson-operation">default toJSON
      operation</a>.</p>
    </section>
    <section data-link-for="PerformanceObserver" data-dfn-for=
    "PerformanceObserver">
      <h2>The <dfn>PerformanceObserver</dfn> interface</h2>
      <p>The <a>PerformanceObserver</a> interface can be used to observe the
      <a>Performance Timeline</a> to be notified of new performance metrics as
      they are recorded, and optionally buffered performance metrics.
      <p>Each <a>PerformanceObserver</a> has these associated concepts:</p>
      <ul>
        <li>A <dfn>PerformanceObserverCallback</dfn> set on creation.</li>
        <li>A list of <a>PerformanceEntry</a> objects called the <dfn>observer
        buffer</dfn> that is initially empty.
        </li>
      </ul>
      <p>The `PerformanceObserver(callback)` constructor must create a new
      <a>PerformanceObserver</a> object with <a>PerformanceObserverCallback</a>
      set to <var>callback</var> and then return it.</p>
      <p>A <dfn>registered performance observer</dfn> consists of an observer
      (a <a>PerformanceObserver</a> object) and options (a
      <a>PerformanceObserverInit</a> dictionary).</p>
      <pre class="idl">
      callback PerformanceObserverCallback = void (PerformanceObserverEntryList entries,
                                                   PerformanceObserver observer);
      [Constructor(PerformanceObserverCallback callback), Exposed=(Window,Worker)]
      interface PerformanceObserver {
        void observe (PerformanceObserverInit options);
        void disconnect ();
        PerformanceEntryList takeRecords();
        static readonly attribute sequence<DOMString> entryTypes;
      };
      </pre>
      <p class="note">To keep the performance overhead to minimum the
      application should only subscribe to event types that it is interested
      in, and disconnect the observer once it no longer needs to observe the
      performance data. Filtering by name is not supported, as it would
      implicitly require a subscription for all event types — this is possible,
      but discouraged, as it will generate a significant volume of events.</p>
      <section>
        <h2><dfn>observe()</dfn> method</h2>
        <p>The <a>observe()</a> method instructs the user agent to
        <dfn>register the observer</dfn> and must run these steps:</p>
        <ol data-link-for="PerformanceObserverInit">
          <li>Filter unsupported names within the `entryTypes` sequence, and
          replace the `entryTypes` sequence with the new filtered sequence.
          </li>
          <li>If the resulting '<a>entryTypes</a>' sequence is an empty sequence, abort
            these steps. The user agent SHOULD notify developers when the steps are
            aborted. A console warning listing ignored unsupported names in `entryTypes`
            might be appropriate, for example.
          </li>
          <li>If the list of <a>registered performance observer</a> objects
          associated with the <a>ECMAScript global environment</a> of the
          interface object's contains a <a>registered performance observer</a>
          that is the <a>context object</a>, replace the <a>context object</a>'s
          `options` with <var>options</var>.
          </li>
         <li>Otherwise, append a new <a>registered performance observer</a>
          object to the list of <a>registered performance observer</a> objects
          associated with the <a>ECMAScript global environment</a> of the
          interface object, with the <a>context object</a> as `observer` and
          <var>options</var> as the `options`.
          </li>
          <li>If _options'_ <a for="PerformanceObserverInit">buffered</a> flag is
            set, for each <dfn>entryType</dfn> of the `entryTypes` sequence:
            <ol>
              <li>Let <dfn>entries</dfn> be the <a>PerformanceEntryList</a>
              object returned by the
              <a href="#filter-buffer-by-name-and-type"></a> algorithm with
              <var>buffer</var> set to <a>performance entry buffer</a>,
              <var>name</var> set to `null` and <var>type</var> set to
              <var>entryType</var>.
              </li>
              <li>Append <var>entries</var> to the <a>context object</a>'s
              <a>observer buffer</a>.
              </li>
            </ol>
          </li>
        </ol>
        <section data-dfn-for="PerformanceObserverInit" data-link-for=
        "PerformanceObserverInit">
          <h2><dfn>PerformanceObserverInit</dfn> dictionary</h2>
          <pre class="idl">
          dictionary PerformanceObserverInit {
            required sequence&lt;DOMString&gt; entryTypes;
            boolean buffered = false;
          };
          </pre>
          <dl>
            <dt><dfn>entryTypes</dfn></dt>
            <dd>A list of entry names to be observed. The list MUST NOT be empty
            and types not recognized by the user agent MUST be ignored.</dd>
          </dl>
          <dl>
            <dt><dfn>buffered</dfn></dt>
            <dd>A flag to indicate whether buffered entries should be queued into
            observer's buffer.</dd>
          </dl>
        </section>
        <section data-dfn-for="PerformanceObserverEntryList" data-link-for=
      "PerformanceObserverEntryList">
          <h2><dfn>PerformanceObserverEntryList</dfn> interface</h2>
          <pre class="idl">
          [Exposed=(Window,Worker)]
          interface PerformanceObserverEntryList {
            PerformanceEntryList getEntries();
            PerformanceEntryList getEntriesByType (DOMString type);
            PerformanceEntryList getEntriesByName (DOMString name, optional DOMString type);
          };
          </pre>
          <section>
            <h2><dfn>getEntries()</dfn> method</h2>
            <p>Returns a <a>PerformanceEntryList</a> object returned by
            <a href="#filter-buffer-by-name-and-type"></a> algorithm with
            <var>buffer</var> set to <a>observer buffer</a>, and
            <var>name</var> and <var>type</var> set to `null`.</p>
          </section>
          <section>
            <h2><dfn>getEntriesByType()</dfn> method</h2>
            <p>Returns a <a>PerformanceEntryList</a> object returned by
            <a href="#filter-buffer-by-name-and-type"></a> algorithm with
            <var>buffer</var> set to <a>observer buffer</a>,
            <var>name</var> set to `null`, and <var>type</var> set
            to `type`.</p>
          </section>
          <section>
            <h2><dfn>getEntriesByName()</dfn> method</h2>
            <p>Returns a <a>PerformanceEntryList</a> object returned by
            <a href="#filter-buffer-by-name-and-type"></a> algorithm with
            <var>buffer</var> set to <a>observer buffer</a>,
            <var>name</var> set to `name`, and <var>type</var> set
            to `null` if optional `entryType` is omitted, and <var>type</var> set
            to `type` otherwise.</p>
          </section>
        </section>
      </section>
      <section>
        <h2><dfn>takeRecords()</dfn> method</h2>
        <p>The <a>takeRecords()</a> method instructs the user agent to flush  entries in <a>context object</a>'s <a>observer buffer</a> and must run these steps:</p>
        <ol data-link-for="PerformanceObserver">
          <li>Let <var>entries</var> be a copy of <a>context object</a>'s <a>observer buffer</a>.</li>
          <li>Empty <a>context object</a>'s <a>observer buffer</a>.</li>
          <li>Return <var>entries</var>.</li>
        </ol>
      </section>
      <section>
        <h2><dfn>disconnect()</dfn> method</h2>
        <p>The <a>disconnect()</a> method must remove the <a>context object</a>
        from the list of <a>PerformanceObserver</a> objects associated with the
        <a>ECMAScript global environment</a> of the interface object, and also
        empty <a>context object</a>'s <a>observer buffer</a>.</p>
      </section>
      <section>
        <h2><dfn>entryTypes</dfn> attribute</h2>
        <p>This attribute MUST return a list of entry types supported by the `PerformanceObserver` interface.</p>
        <div class="issue">
          <p>The above states the intent, but we need to wire up the actual plumbing to define how this ought to be implemented. To that end, a few observations..</p>

          <p>This spec defines the <a>performance entry buffer</a>, which we treat as a global buffer shared by all upstream emitters and which we query via `getEntries`, `getEntriesByName`, etc. <b>However</b>, in practice this is not how UA's implement this functionality. Instead of a global buffer, all implementations maintain separate buffers (each with own size limit), which we then query depending on name/type, etc. Further, some specs <b>strong</b> define own buffer management logic (e.g. ResourceTiming).</p>

          <p>We need to align our spec with implementation realities and also, ideally, define clear extension and reuse primitives to reduce duplication across specs. One way we could do this...</p>

          <ul>
            <li>Define a mechanism registry where upstream specs can register themselves with Peformance Timeline (this spec). The registration could consisnt of `name` and `size`, and Perf Timeline would then create the associated buffer and maintain it — run the add steps, enforce size constraints, etc.</li>
            <li>Once we have the registry, we can also explain and define entryTypes — we have a list of registered names and that's what we'll return.</li>
            <li>We can update upstream specs with "X register itself with Performance Timeline with name X and buffer size Y" — this makes the connection explicit and allows us to avoid redefining buffer logic in each upstream emitter</li>
          </ul>

          Crazytalk? The above is effectively what we <a href="https://github.com/w3c/performance-timeline/issues/81#issuecomment-317089343">converged on at the f2f</a>.
        </p>
      </section>
    </section>
  </section>
  <section>
    <h2>Processing</h2>
    <section data-link-for="PerformanceObserver">
    <h2>Queue a <code>PerformanceEntry</code></h2>
      <p>To <dfn>queue a PerformanceEntry</dfn> (<var>new entry</var>) with an
      optional <var>add to performance entry buffer</var> flag, which is unset
      by default, run these steps:</p>
    <ol>
      <li>Let <i>interested observers</i> be an initially empty set of
      <a>PerformanceObserver</a> objects.
      </li>
      <li>For each <a>registered performance observer</a> (<i>observer</i>):
        <ol>
          <li>If <i>observer</i>'s <a>PerformanceObserverInit</a> <a data-lt=
          "PerformanceObserverInit.entryTypes">entryTypes</a> includes <i>new
          entry</i>’s <a data-lt="PerformanceEntry.entryType">entryType</a>
          value, append <i>observer</i> to <i>interested observers</i>.
          </li>
        </ol>
      </li>
      <li>For each <i>observer</i> in <i>interested observers</i>:
        <ol>
          <li>Append <i>new entry</i> to <a>observer buffer</a>.
          </li>
        </ol>
      </li>
      <li>If the <var>add to performance entry buffer</var> flag is set, add
        <i>new entry</i> to the <a>performance entry buffer</a>.
      </li>
      <li>If the <a>performance observer task queued flag</a> is set, terminate
      these steps.
      </li>
      <li>Set <a>performance observer task queued flag</a>.
      </li>
      <li>
        <a>Queue a task</a> that consists of running the following substeps.
        The <a>task source</a> for the queued task is the <i>performance
        timeline</i> task source.
        <ol>
          <li>Unset <a>performance observer task queued flag</a>.
          </li>
          <li>Let <i>notify list</i> be a copy of <a>ECMAScript global
          environment</a>'s list of <a>registered performance observer</a>
          objects.
          </li>
          <li>For each <a>PerformanceObserver</a> object <i>po</i> in <i>notify
          list</i>, run these steps:
            <ol>
              <li>Let <i>entries</i> be a copy of <i>po</i>’s <a>observer
              buffer</a>.
              </li>
              <li>Empty <i>po</i>’s <a>observer buffer</a>.
              </li>
              <li>If <i>entries</i> is non-empty, call <i>po</i>’s callback
              with <i>entries</i> as first argument and <i>po</i> as the second
              argument and <a>callback this value</a>. If this throws an
              exception, <a>report the exception</a>.
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <p>The <i>performance timeline</i> <a>task queue</a> is a low priority
    queue that, if possible, should be processed by the user agent during idle
    periods to minimize impact of performance monitoring code.</p>
    </section>
    <section data-link-for="PerformanceEntry">
      <h2>Filter <var>buffer</var> by <var>name</var> and <var>type</var></h2>
      <p>Given a <var>buffer</var> and optional <var>name</var> and
      <var>type</var> string values this algorithm returns a
      <a>PerformanceEntryList</a> object that contains a list of
      <a>PerformanceEntry</a> objects sorted in chronological order with respect
      to <a>startTime</a>; objects with the same <a>startTime</a> have
      unspecified ordering.</p>
      <ol>
        <li>Let the <dfn>list of entry objects</dfn> be the empty
        <a>PerformanceEntryList</a>.
        </li>
        <li>For each <a>PerformanceEntry</a> object (<dfn>entryObject</dfn>) in
        the <var>buffer</var>, in chronological order with
        respect to <a>startTime</a>:
          <ol>
            <li>If <var>name</var> is not `null` and <a>entryObject</a>'s
            `name` attribute does not match <var>name</var> in a
            <a>case-sensitive</a> manner, go to next <a>entryObject</a>.
            </li>
            <li>If <var>type</var> is not `null` and <a>entryObject</a>'s
            `type` attribute does not match <var>type</var> in a
            <a>case-sensitive</a> manner, go to next <a>entryObject</a>.
            </li>
            <li>Add <a>entryObject</a> to the <a>list of entry objects</a>.
            </li>
          </ol>
        </li>
        <li>Return the <a>list of entry objects</a>.
        </li>
      </ol>
    </section>
  </section>
  <section>
    <h2>Dependencies</h2>
    <p>This specification depends on the following interfaces, attributes,
    concepts, and terms which are defined in their linked specifications.</p>
    <ul>
      <li><code><dfn data-cite=
      "!hr-time-2#idl-def-Performance">Performance</dfn></code> interface</li>
      <li><code><dfn data-cite=
      "!resource-timing#idl-def-PerformanceResourceTiming">PerformanceResourceTiming</dfn></code>
      interface</li>
      <li><dfn data-cite=
      "!resource-timing#widl-PerformanceResourceTiming-initiatorType">initiatorType</dfn></li>
      <li><dfn data-cite="!WebIDL#dfn-callback-this-value">callback this
      value</dfn></li>
      <li><dfn data-cite="!WebIDL#dfn-conforming-idl-fragment">conforming IDL
      fragments</dfn></li>
      <li><dfn data-cite="!WebIDL#dfn-dictionary-member">dictionary
      member</dfn></li>
      <li><dfn data-cite="!WebIDL#dfn-throw">throw</dfn></li>
      <li><dfn data-cite="!WebIDL#es-environment">ECMAScript global
      environment</dfn></li>
      <li><dfn data-cite="!WHATWG-DOM#context-object">context object</dfn></li>
      <li><dfn data-cite=
      "!WHATWG-HTML#case-sensitive">case-sensitive</dfn></li>
      <li><dfn data-cite="!WHATWG-HTML#queue-a-task">queue a task</dfn></li>
      <li><dfn data-cite="!WHATWG-HTML#report-the-exception">report the
      exception</dfn></li>
      <li><dfn data-cite="!WHATWG-HTML#task-queue">task queue</dfn></li>
      <li><dfn data-cite="!WHATWG-HTML#task-source">task source</dfn></li>
    </ul>
  </section>
  <section id="privacy-security">
    <h3>Privacy and Security</h3>
    <p>This specification extends the <a>Performance</a> interface defined by
    [[HR-TIME-2]] and provides methods to queue and retrieve entries from the
    <a>performance timeline</a>. Please refer to [[HR-TIME-2]] for privacy and
    security considerations of exposing high-resoluting timing information.</p>
  </section>
  <section class="appendix" id="idl-index"></section>
  <section class="appendix">
    <h2>Acknowledgments</h2>
    <p>Thanks to Arvind Jain, Boris Zbarsky, Jatinder Mann, Nat Duca, Philippe
    Le Hegaret, Ryosuke Niwa, Shubhie Panicker, Todd Reifsteck, Yoav Weiss, and
    Zhiheng Wang, for their contributions to this work.</p>
  </section>
</body>
</html>
